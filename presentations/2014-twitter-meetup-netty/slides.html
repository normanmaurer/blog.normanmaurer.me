<!DOCTYPE html><html lang="en" class="aspect-16-9"><head><meta charset="UTF-8"><meta name="generator" content="Asciidoctor 0.1.4, dzslides backend"><title>Netty - Best Practices a.k.a Faster == Better</title><meta name="author" content="@Twitter 2014"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton:400,700,800,400italic|Cedarville+Cursive"><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css"><link rel="stylesheet" href="./dzslides/themes/highlight/asciidoctor.css"><link rel="stylesheet" href="./dzslides/themes/style/asciidoctor.css"><style>section:not(.topic) > h2 { display: none;}</style><link rel="stylesheet" href="./dzslides/core/dzslides.css"><link rel="stylesheet" href="./dzslides/themes/transition/fade.css"></head><body><section class="title"><h1><em>Netty</em> - Best Practices a.k.a <em>Faster == Better</em></h1><footer><span class="author">@Twitter 2014</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">San Francisco</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">2014/07/28</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">@normanmaurer</span></footer></section><section class="topic source"><h2>Agenda</h2><div class="exampleblock"><div class="content"><ul><li><em class="icon-note">&#8203;</em> HTTP / Pipelining</li><li><em class="icon-note">&#8203;</em> Writing gracefully</li><li><em class="icon-note">&#8203;</em> Buffers best-practises</li><li><em class="icon-note">&#8203;</em> EventLoop</li></ul></div></div></section>
<section class="topic source"><h2>No Pipelining Optimization</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class HttpHandler extends SimpleChannelInboundHandler&lt;HttpRequest&gt; {
  @Override
  public void channelRead(ChannelHandlerContext ctx, HttpRequest req) {
    ChannelFuture future = ctx.writeAndFlush(createResponse(req)); <i class="conum" data-value="1"></i><b>(1)</b>
    if (!isKeepAlive(req)) {
      future.addListener(ChannelFutureListener.CLOSE); <i class="conum" data-value="2"></i><b>(2)</b>
    }
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><em>Write</em> to the Channel and <em>flush</em> out to the Socket.</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>After written <em>close</em> Socket</td></tr></table></div></section>
<section class="topic source"><h2>Pipelining to safe syscalls!</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class HttpPipeliningHandler extends SimpleChannelInboundHandler&lt;HttpRequest&gt; {
  @Override
  public void channelRead(ChannelHandlerContext ctx, HttpRequest req) {
    ChannelFuture future = ctx.write(createResponse(req)); <i class="conum" data-value="1"></i><b>(1)</b>
    if (!isKeepAlive(req)) {
      future.addListener(ChannelFutureListener.CLOSE); <i class="conum" data-value="2"></i><b>(2)</b>
    }
  }
  @Override
  public void channelReadComplete(ChannelHandlerContext ctx) {
    ctx.flush(); <i class="conum" data-value="3"></i><b>(3)</b>
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><em>Write</em> to the <code>Channel</code> (<em>No syscall!</em>) but don&#8217;t flush yet</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td><em>Close</em> socket when done writing</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td><em>Flush</em> out to the socket.</td></tr></table></div></section>
<section class="topic source"><h2>Validate headers or not ?</h2><div class="listingblock"><div class="title"><code>Validate headers for US-ASCII</code></div><pre class="highlight CodeRay"><code class="java">ChannelPipeline pipeline = channel.pipeline();
pipeline.addLast(new HttpRequestDecoder(4096, 8192, 8192));

HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.OK);</code></pre></div>
<div class="listingblock"><div class="title"><code>Not validate headers for US-ASCII</code></div><pre class="highlight CodeRay"><code class="java">ChannelPipeline pipeline = channel.pipeline();
pipeline.addLast(new HttpRequestDecoder(4096, 8192, 8192, false));

HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.OK, false);</code></pre></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Validation takes time and most of the times it is not needed directly in the decoder/encoder.</td></tr></table></div></section>
<section class="topic source"><h2>Static header names and values via HttpHeaders.newEntity(&#8230;).</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">private static final CharSequence X_HEADER_NAME = HttpHeaders.newEntity("X-Header"); <i class="conum" data-value="1"></i><b>(1)</b>
private static final CharSequence X_VALUE = HttpHeaders.newEntity("Value");

pipeline.addLast(new SimpleChannelInboundHandler&lt;FullHttpRequest&gt;() {
  @Override
  public void channelRead(ChannelHandlerContext ctx, FullHttpRequest req) {
    FullHttpResponse response = new FullHttpResponse(HTTP_1_1, OK);
    response.headers().set(X_HEADER_NAME, X_VALUE); <i class="conum" data-value="2"></i><b>(2)</b>
    ...
    ctx.writeAndFlush(response);
  }
});</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Create <code>CharSequence</code> for often used header names and values.</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Add to <code>HttpHeader</code> of <code>FullHttpResponse</code></td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Created <code>CharSequence</code> is faster to encode and faster to find in <code>HttpHeaders</code>.</td></tr></table></div></section>
<section class="topic source"><h2>write(msg) , flush() and writeAndFlush(msg)</h2><p><em>write(msg)</em> &#8658; pass through pipeline</p>
<p><em>flush()</em> &#8658; gathering write of previous written msgs</p>
<p><em>writeAndFlush()</em> &#8658; short-cut for <em>write(msg)</em> and <em>flush()</em></p>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Limit flushes as much as possible as syscalls are quite expensive.</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">But also limit <code>write(...)</code> as much as possible as it need to traverse the whole pipeline.</td></tr></table></div></section>
<section class="topic source"><h2>May write too fast!</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class BlindlyWriteHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelActive(ChannelHandlerContext ctx) throws Exception {
    while(needsToWrite) { <i class="conum" data-value="1"></i><b>(1)</b>
        ctx.writeAndFlush(createMessage());
    }
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Writes till <code>needsToWrite</code> returns <code>false</code>.</td></tr></table></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content">Risk of <em>OutOfMemoryError</em> if writing too fast and having slow receiver!</td></tr></table></div></section>
<section class="topic source"><h2>Correctly write with respect to slow receivers</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class GracefulWriteHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelActive(ChannelHandlerContext ctx) {
    writeIfPossible(ctx.channel());
  }
  @Override
  public void channelWritabilityChanged(ChannelHandlerContext ctx) {
    writeIfPossible(ctx.channel());
  }

  private void writeIfPossible(Channel channel) {
    while(needsToWrite &amp;&amp; channel.isWritable()) { <i class="conum" data-value="1"></i><b>(1)</b>
      channel.writeAndFlush(createMessage());
    }
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Make proper use of <code>Channel.isWritable()</code> to prevent <em>OutOfMemoryError</em></td></tr></table></div></section>
<section class="topic source"><h2>Configure high and low write watermarks</h2><div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Set sane <em>WRITE_BUFFER_HIGH_WATER_MARK</em> and <em>WRITE_BUFFER_LOW_WATER_MARK</em></td></tr></table></div>
<div class="listingblock"><div class="title"><code>Server</code></div><pre class="highlight CodeRay"><code class="java">ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 32 * 1024);
bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 8 * 1024);</code></pre></div>
<div class="listingblock"><div class="title"><code>Client</code></div><pre class="highlight CodeRay"><code class="java">Bootstrap bootstrap = new Bootstrap();
bootstrap.option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 32 * 1024);
bootstrap.option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 8 * 1024);</code></pre></div></section>
<section class="topic source"><h2>Issues with using non pooled buffers</h2><div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content">Use unpooled buffers with <em>caution</em>!</td></tr></table></div>
<div class="exampleblock"><div class="content"><ul><li><em class="icon-note">&#8203;</em> Allocation / Deallocation is <em>slow</em></li><li><em class="icon-note">&#8203;</em> Free up direct buffers == <em>PITA</em>!</li></ul></div></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content"><em>Use</em> pooled buffers!</td></tr></table></div>
<div class="listingblock"><pre class="highlight CodeRay"><code class="java">Bootstrap bootstrap = new Bootstrap();
bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</code></pre></div></section>
<section class="topic source"><h2>Use Pooling of buffers to reduce allocation / deallocation time!</h2><div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Pooling pays off for direct and heap buffers!</td></tr></table></div>
<img src="images/pooled_buffers.png" alt="pooled buffers" width="400">
<div class="literalblock"><pre class="literal">https://blog.twitter.com/2013/netty-4-at-twitter-reduced-gc-overhead</pre></div></section>
<section class="topic source"><h2>Always use direct ByteBuffer when writing to SocketChannel</h2><div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content">OpenJDK and Oracle JDK copy otherwise to direct buffer by itself!</td></tr></table></div>
<p>Only use heap buffers if need to operate on byte[]` in <code>ChannelOutboundHandler</code>! By default direct ByteBuf` will be returned by <code>ByteBufAllocator.buffer(...)</code>.</p>
<p><em>Take this as rule of thumb</em></p></section>
<section class="topic source"><h2>Find pattern in ByteBuf</h2><div class="listingblock"><div class="title"><code>SlowSearch :(</code></div><pre class="highlight CodeRay"><code class="java">ByteBuf buf = ...;
int index = -1;
for (int i = buf.readerIndex(); index == -1 &amp;&amp; i &lt;  buf.writerIndex(); i++) {
  if (buf.getByte(i) == '\n') {
    index = i;
  }
}</code></pre></div>
<div class="listingblock"><div class="title"><code>FastSearch :)</code></div><pre class="highlight CodeRay"><code class="java">ByteBuf buf = ...;
int index = buf.forEachByte(new ByteBufProcessor() {
  @Override
  public boolean process(byte value) {
    return value != '\n';
  }
});</code></pre></div></section>
<section class="topic source"><h2>Messages with Payload? Yes please&#8230;</h2><p><code>ByteBuf</code> payload &#8658; extend <code>DefaultByteBufHolder</code></p>
<div class="exampleblock"><div class="content"><ul><li><em class="icon-note">&#8203;</em> reference-counting for free</li><li><em class="icon-note">&#8203;</em> release resources out-of-the-box</li></ul></div></div>
<img src="images/thumb_up_2.jpg" alt="thumb up 2" width="180">
<div class="literalblock"><pre class="literal">http://www.flickr.com/photos/za3tooor/65911648/</pre></div></section>
<section class="topic source"><h2>File transfer ?</h2><div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Use zero-memory-copy for efficient transfer of raw file content</td></tr></table></div>
<div class="listingblock"><pre class="highlight CodeRay"><code class="java">Channel channel = ...;
FileChannel fc = ...;
channel.writeAndFlush(new DefaultFileRegion(fc, 0, fileLength));</code></pre></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content">This only works if you don&#8217;t need to modify the data on the fly. If so use <code>ChunkedWriteHandler</code> and <code>NioChunkedFile</code>.</td></tr></table></div></section>
<section class="topic source"><h2>Never block the EventLoop!</h2><div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content"><code>Thread.sleep()</code></td></tr></table></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content"><code>CountDownLatch.await()</code> or any other blocking operation from
<code>java.util.concurrent</code></td></tr></table></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content">Long-lived computationally intensive operations</td></tr></table></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content">Blocking operations that might take a while (e.g. DB query)</td></tr></table></div>
<img src="images/site_blocked.jpg" alt="site blocked" width="80">
<div class="literalblock"><pre class="literal">http://www.flickr.com/photos/za3tooor/65911648/</pre></div></section>
<section class="topic source"><h2>Re-use EventLoopGroup if you can!</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">Bootstrap bootstrap = new Bootstrap().group(new NioEventLoopGroup());
Bootstrap bootstrap2 = new Bootstrap().group(new NioEventLoopGroup());</code></pre></div>
<div class="listingblock"><div class="title"><code>Share EventLoopGroup between different Bootstraps</code></div><pre class="highlight CodeRay"><code class="java">EventLoopGroup group = new NioEventLoopGroup();
Bootstrap bootstrap = new Bootstrap().group(group);
Bootstrap bootstrap2 = new Bootstrap().group(group);</code></pre></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content"><em>Sharing</em> the same <code>EventLoopGroup</code> allows to keep the resource usage (like Thread-usage) to a minimum.</td></tr></table></div></section>
<section class="topic source"><h2>Proxy like application with context-switching issue</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class ProxyHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelActive(ChannelHandlerContext ctx) { <i class="conum" data-value="1"></i><b>(1)</b>
    final Channel inboundChannel = ctx.channel();
    Bootstrap b = new Bootstrap();
    b.group(new NioEventLooopGroup()); <i class="conum" data-value="2"></i><b>(2)</b>
    ...
    ChannelFuture f = b.connect(remoteHost, remotePort);
    ...
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Called once a new connection was accepted</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Use a new <code>EventLoopGroup</code> instance to handle the connection to the remote peer</td></tr></table></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="icon-caution" title="Caution"></i></td><td class="content">Don&#8217;t do this! This will tie up more resources than needed and introduce extra context-switching overhead.</td></tr></table></div></section>
<section class="topic source"><h2>Proxy like application which reduce context-switching to minimum</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class ProxyHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelActive(ChannelHandlerContext ctx) { <i class="conum" data-value="1"></i><b>(1)</b>
    final Channel inboundChannel = ctx.channel();
    Bootstrap b = new Bootstrap();
    b.group(inboundChannel.eventLoop()); <i class="conum" data-value="2"></i><b>(2)</b>
    ...
    ChannelFuture f = b.connect(remoteHost, remotePort);
    ...
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Called once a new connection was accepted</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Share the same <code>EventLoop</code> between both Channels. This means all IO for both connected Channels are handled by the same Thread.</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Always <em>share</em> EventLoop in those Applications</td></tr></table></div></section>
<section class="topic source"><h2>Operations from inside ChannelHandler</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class YourHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelActive(ChannelHandlerContext ctx) {
    // BAD (most of the times)
    ctx.channel().writeAndFlush(msg); <i class="conum" data-value="1"></i><b>(1)</b>

    // GOOD
    ctx.writeAndFlush(msg); <i class="conum" data-value="2"></i><b>(2)</b>
   }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><code>Channel.*</code> methods  &#8658; the operation will start at the tail of the <code>ChannelPipeline</code></td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td><code>ChannelHandlerContext.* methods =&gt;  the operation will start from this `ChannelHandler</code> to flow through the <code>ChannelPipeline</code>.</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Use the shortest <em>path</em> as possible to get the maximal performance.</td></tr></table></div></section>
<section class="topic source"><h2>Share ChannelHandlers if stateless</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">@ChannelHandler.Shareable <i class="conum" data-value="1"></i><b>(1)</b>
public class StatelessHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelActive(ChannelHandlerContext ctx) {
    logger.debug("Now client from " + ctx.channel().remoteAddress().toString());
   }
}

public class MyInitializer extends ChannelInitializer&lt;Channel&gt; {
  private static final ChannelHandler INSTANCE = new StatelessHandler();
  @Override
  public void initChannel(Channel ch) {
    ch.pipeline().addLast(INSTANCE);
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Annotate <code>ChannelHandler</code> that are stateless with <code>@ChannelHandler.Shareable</code> and use the same instance accross Channels to reduce GC.</td></tr></table></div></section>
<section class="topic source"><h2>Remove ChannelHandler once not needed anymore</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class OneTimeHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void channelActive(ChannelHandlerContext ctx) {
    doOneTimeAction();
    ctx.channel().pipeline().remove(this); <i class="conum" data-value="1"></i><b>(1)</b>
   }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Remove <code>ChannelHandler</code> once not needed anymore.</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">This keeps the <code>ChannelPipeline</code> as <em>short</em> as possible and so <em>eliminate overhead</em> of traversing as much as possible.</td></tr></table></div></section>
<section class="topic source"><h2>Pass custom events through <code>ChannelPipeline</code></h2><div class="listingblock"><div class="title"><code>Your custom events</code></div><pre class="highlight CodeRay"><code class="java">public enum CustomEvents {
  MyCustomEvent
}

public class CustomEventHandler extends ChannelInboundHandlerAdapter {
  @Override
  public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
    if (evt == MyCustomEvent) { // do something}
  }
}

ChannelPipeline pipeline = channel.pipeline();
pipeline.fireUserEventTriggered(MyCustomEvent);</code></pre></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Good fit for handshake notifications and more</td></tr></table></div></section>
<section class="topic source"><h2>Use proper buffer type in MessageToByteEncoder</h2><div class="listingblock"><pre class="highlight CodeRay"><code class="java">public class EncodeActsOnByteArray extends MessageToByteEncoder&lt;YourMessage&gt; {
  public EncodeActsOnByteArray() { super(false); } <i class="conum" data-value="1"></i><b>(1)</b>
  @Override
  public encode(ChannelHandlerContext ctx, YourMessage msg, ByteBuf out) {
    byte[] array = out.array(); <i class="conum" data-value="2"></i><b>(2)</b>
    int offset = out.arrayOffset() + out.writerIndex();
    out.writeIndex(out.writerIndex() + encode(msg, array, offset)); <i class="conum" data-value="3"></i><b>(3)</b>
  }
  private int encode(YourMessage msg, byte[] array, int offset, int len) { ... }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Ensure <em>heap buffers</em> are used when pass into <code>encode(...)</code> method. This way you can access the backing array directly</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Access the <em>backing array</em> and also calculate offset</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Update <em>writerIndex</em> to reflect written bytes</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">This saves extra byte copies.</td></tr></table></div></section>
<section class="topic source"><h2>To auto-read or not to auto-read</h2><p>By default Netty will keep on reading data from the <code>Channel</code> once something is ready.</p>
<div class="listingblock"><div class="title"><code>Need more fine grained control ?</code></div><pre class="highlight CodeRay"><code class="java">channel.config().setAutoRead(false); <i class="conum" data-value="1"></i><b>(1)</b>
channel.read(); <i class="conum" data-value="2"></i><b>(2)</b>
channel.config().setAutoRead(true); <i class="conum" data-value="3"></i><b>(3)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Disable auto read == no more data will be read automatically from this <code>Channel</code>.</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Tell the <code>Channel</code> to do one read operation once new data is ready</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Enable again auto read == Netty will automatically read again</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">This can also be quite useful when writing proxy like applications!</td></tr></table></div></section>
<section class="topic source"><h2>Native stuff in Netty 4</h2><div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">OpenSSL based SslEngine to reduce memory usage and latency.</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Native transport for Linux using Epoll ET for more performance and less CPU usage.</td></tr></table></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Native transport also supports SO_REUSEPORT and TCP_CORK :)</td></tr></table></div>
<img src="images/200px-Tux.svg.png" alt="200px Tux.svg" width="100"></section>
<section class="topic source"><h2>Switching to native transport is easy</h2><div class="listingblock"><div class="title"><code>Using NIO transport</code></div><pre class="highlight CodeRay"><code class="java">Bootstrap bootstrap = new Bootstrap().group(new NioEventLoopGroup());
bootstrap.channel(NioSocketChannel.class);</code></pre></div>
<div class="listingblock"><div class="title"><code>Using native transport</code></div><pre class="highlight CodeRay"><code class="java">Bootstrap bootstrap = new Bootstrap().group(new EpollEventLoopGroup());
bootstrap.channel(EpollSocketChannel.class);</code></pre></div></section>
<section class="topic source"><h2>Want to know more?</h2><div class="admonitionblock tip"><table><tr><td class="icon"><i class="icon-tip" title="Tip"></i></td><td class="content">Buy my book <a href="http://www.manning.com/maurer/">Netty in Action</a> and make me <em>RICH</em>.</td></tr></table></div>
<img src="images/maurer_cover150.jpg" alt="maurer cover150" width="100">
<div class="literalblock"><pre class="literal">http://www.manning.com/maurer</pre></div>
<p><em>$ KA-CHING $</em></p></section>
<section class="topic source"><h2>References</h2><div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Netty - <a href="http://netty.io">http://netty.io</a></td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Slides generated with Asciidoctor and DZSlides backend</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Original slide template - Dan Allen &amp; Sarah White</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">All pictures licensed with <code>Creative Commons Attribution</code> or<br>
<code>Creative Commons Attribution-Share Alike</code></td></tr></table></div></section>
<section class="topic ending"><h2 class="name">Norman Maurer</h2><p class="footer"><em class="icon-twitter">&#8203;</em> @normanmaurer</p></section><script src="./dzslides/core/dzslides.js"></script><script src="./dzslides/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad()</script></body></html>